import { getModernPostBySlug, getModernPostBySlugWithPreview, getStarterPackForPost, getLegacyBlogPostBySlug, supabase } from "@/lib/supabase"
import { DynamicSectionRenderer } from "@/components/dynamic-section-renderer"
import { Footer } from "@/components/footer"
import { LanguageSwitcher } from "@/components/LanguageSwitcher"
import { LogoImage } from "@/components/LogoImage"
import { notFound } from "next/navigation"
import { Button } from "@/components/ui/button"
import { ArrowLeft } from "lucide-react"
import Link from "next/link"
import { BlogArticleTemplate } from "@/components/blog-article-template"
import { convertBlogPostToTemplate } from "@/lib/blog-template-utils"
import { convertPostToTemplate } from "@/lib/blog-template-generator"
import { convertLegacyPostToTemplate } from "@/lib/legacy-blog-template-generator"
import { cookies } from 'next/headers'
import { slugMappings } from '@/lib/slug-mappings'

interface BlogPostPageProps {
  params: Promise<{
    slug: string[]
  }>
  searchParams: Promise<{
    preview?: string
  }>
}

export default async function BlogPostPage({ params, searchParams }: BlogPostPageProps) {
  try {
    const resolvedParams = await params
    const resolvedSearchParams = await searchParams
    const isPreview = resolvedSearchParams.preview === 'true'
  
    // Parse the slug array to determine country, language, and post slug
    const slugArray = resolvedParams.slug
    let country: string | null = null
    let language: string = 'en' // Default language
    let postSlug: string | null = null
    let fullSlug: string | null = null

    if (slugArray.length === 2) {
      // Format: /blog/country/post-name
      country = slugArray[0]
      postSlug = slugArray[1]
      fullSlug = `${country}/${postSlug}`
    } else if (slugArray.length === 3) {
      // Format: /blog/country/lang/post-name
      country = slugArray[0]
      language = slugArray[1]
      postSlug = slugArray[2]
      fullSlug = `${country}/${postSlug}` // Database still uses country/post-name format
    } else if (slugArray.length === 1) {
      // Fallback for old format: /blog/post-name
      postSlug = slugArray[0]
      fullSlug = postSlug
    } else {
      // Invalid URL structure
      notFound()
    }

    console.log('URL parsing debug:', {
      originalSlugArray: slugArray,
      country,
      language,
      postSlug,
      fullSlug
    })
    
    console.log('About to query for post with:', { fullSlug, postSlug })
  
  // Check authentication for preview mode
  if (isPreview) {
    const cookieStore = await cookies()
    const sessionCookie = cookieStore.get('sb-access-token') || cookieStore.get('sb-refresh-token')
    
    if (!sessionCookie) {
      return (
        <div className="min-h-screen flex items-center justify-center bg-gray-50">
          <div className="max-w-md w-full bg-white rounded-lg shadow-md p-6 text-center">
            <h1 className="text-2xl font-bold text-gray-900 mb-4">Preview Access Required</h1>
            <p className="text-gray-600 mb-6">
              You need to be logged in to preview draft posts.
            </p>
            <Link href="/admin" className="bg-blue-600 hover:bg-blue-700 text-white px-6 py-2 rounded-md inline-block">
              Sign In
            </Link>
          </div>
        </div>
      )
    }
  }
  
  // First try to get modern post with full slug (new format), then fallback to postSlug (original format)
  let post = isPreview 
    ? await getModernPostBySlugWithPreview(fullSlug, true)
    : await getModernPostBySlug(fullSlug)
  
  console.log('First query result:', { found: !!post, searchedSlug: fullSlug })
  
  // If not found with full slug, try with just the post slug (original format)
  if (!post && postSlug) {
    post = isPreview 
      ? await getModernPostBySlugWithPreview(postSlug, true)
      : await getModernPostBySlug(postSlug)
    
    console.log('Fallback query result:', { found: !!post, searchedSlug: postSlug })
  }
  
  let isLegacyPost = false
  let legacyPost = null
  
  // If no modern post found, try legacy blog_posts table
  if (!post && postSlug) {
    legacyPost = await getLegacyBlogPostBySlug(postSlug)
    if (legacyPost) {
      isLegacyPost = true
      console.log('Found legacy post:', {
        id: legacyPost.id,
        title: legacyPost.title,
        contentLength: legacyPost.content?.length || 0
      })
    }
  }
  
  if (!post && !legacyPost) {
    notFound()
  }

  let translatedPost = post
  let translations = null
  
  try {
    // Get available translations for this post (only for modern posts)
    if (!isLegacyPost && post) {
      const { data: translationData } = await supabase
        .from('post_translations')
        .select('language_code, translated_slug, translation_status')
        .eq('original_post_id', post.id)
        .eq('translation_status', 'completed')
      
      translations = translationData
      
      // Handle translation content for non-English languages
      if (language !== 'en' && translations) {
        const translation = translations.find(t => t.language_code === language)
        if (translation) {
          // Get the translated content
          const { data: translationContent } = await supabase
            .from('post_translations')
            .select('translated_title, translated_excerpt, translated_content, seo_data')
            .eq('original_post_id', post.id)
            .eq('language_code', language)
            .single()

          if (translationContent) {
            // Merge translation data with original post
            translatedPost = {
              ...post,
              title: translationContent.translated_title || post.title,
              excerpt: translationContent.translated_excerpt || post.excerpt,
              content: translationContent.translated_content || post.content,
              // Apply SEO data from translation if available
              ...(translationContent.seo_data || {})
            }
          }
        }
      }
    }
  } catch (error) {
    console.error('Error fetching translations:', error)
    translations = null
  }

  // Get starter pack data for this post (only for modern posts)  
  let starterPackData = null
  try {
    if (!isLegacyPost && post) {
      starterPackData = await getStarterPackForPost(post.id)
    }
  } catch (error) {
    console.error('Error fetching starter pack data:', error)
  }

  // Inject starter pack data into relevant sections
  if (starterPackData && translatedPost.sections) {
    try {
      translatedPost.sections = translatedPost.sections.map(section => {
        // Find starter pack or overview intro sections
        const isStarterPackSection = 
          section.template_id === 'b87245be-1b68-47d4-83a6-fac582a0847f' || // StarterPackSection
          section.template_id === '8642ef7e-6198-4cd4-b0f9-8ba6bb868951' || // OverviewIntro
          section.template_id === 'overview-intro' ||
          section.template_id === 'starter-pack-section'

        if (isStarterPackSection) {
          return {
            ...section,
            data: {
              ...section.data,
              starterPackData: starterPackData
            }
          }
        }
        
        return section
      })
    } catch (error) {
      console.error('Error injecting starter pack data:', error)
    }
  }

  // For legacy posts, we'll always use the template system with the real content
  if (isLegacyPost && legacyPost) {
    const legacyTemplateData = convertLegacyPostToTemplate(legacyPost)
    const convertedLegacyPost = convertBlogPostToTemplate(legacyTemplateData)

    // JSON-LD structured data for SEO for legacy post
    const legacyJsonLd = {
      '@context': 'https://schema.org',
      '@type': 'Article',
      headline: legacyPost.title,
      description: legacyPost.excerpt || '',
      image: legacyPost.featured_image_url || '',
      datePublished: legacyPost.published_at,
      dateModified: legacyPost.modified_at || legacyPost.updated_at,
      author: {
        '@type': 'Person',
        name: legacyTemplateData.author.display_name,
      },
      publisher: {
        '@type': 'Organization',
        name: 'CuddlyNest',
        logo: {
          '@type': 'ImageObject',
          url: 'https://cuddlynest.com/logo.png',
        },
      },
      mainEntityOfPage: {
        '@type': 'WebPage',
        '@id': `https://cuddlynest.com/blog/${fullSlug}`,
      },
      articleSection: 'Travel Guide',
      keywords: `travel, ${legacyPost.title}, travel guide`,
    }

    return (
      <>
        {/* JSON-LD Structured Data for Legacy Post */}
        <script
          type="application/ld+json"
          dangerouslySetInnerHTML={{ __html: JSON.stringify(legacyJsonLd) }}
        />

        <BlogArticleTemplate 
          article={convertedLegacyPost} 
          availableTranslations={[]} // No translations for legacy posts
        />
      </>
    )
  }

  const hasSections = translatedPost?.sections && translatedPost.sections.length > 0
  
  console.log('BlogPostPage debug:', {
    postId: translatedPost?.id,
    postTitle: translatedPost?.title,
    sectionsCount: translatedPost?.sections?.length || 0,
    hasSections,
    originalWpId: (translatedPost as any)?.original_wp_id,
    isLegacyPost,
    language,
    country
  })

  // Check if post should use the new template based on database settings
  const shouldUseNewTemplate = translatedPost?.template_enabled === true || translatedPost?.template_type === 'article_template'

  // JSON-LD structured data for SEO
  const jsonLd = {
    '@context': 'https://schema.org',
    '@type': 'Article',
    headline: translatedPost.title,
    description: translatedPost.excerpt || '',
    image: translatedPost.og_image?.file_url || '',
    datePublished: translatedPost.published_at,
    dateModified: translatedPost.updated_at || translatedPost.published_at,
    author: {
      '@type': 'Person',
      name: translatedPost.author?.display_name || 'CuddlyNest Travel Team',
    },
    publisher: {
      '@type': 'Organization',
      name: 'CuddlyNest',
      logo: {
        '@type': 'ImageObject',
        url: 'https://cuddlynest.com/logo.png',
      },
    },
    mainEntityOfPage: {
      '@type': 'WebPage',
      '@id': `https://cuddlynest.com/blog/${slugArray.join('/')}`,
    },
    articleSection: 'Travel Guide',
    keywords: translatedPost.meta_keywords || `travel, ${translatedPost.title}, travel guide`,
  }

  // Use new template for posts marked for template usage
  if (shouldUseNewTemplate) {
    // Use automated template generation for all posts
    const templateData = convertPostToTemplate(translatedPost)
    const convertedPost = convertBlogPostToTemplate(templateData)

    return (
      <>
        {/* JSON-LD Structured Data */}
        <script
          type="application/ld+json"
          dangerouslySetInnerHTML={{ __html: JSON.stringify(jsonLd) }}
        />

        <BlogArticleTemplate 
          article={convertedPost} 
          availableTranslations={translations || []} 
        />
      </>
    )
  }

  // Build the correct current URL for language switcher
  // Use the actual slug from the post, not the constructed fullSlug
  const baseSlug = country ? `${country}/${postSlug}` : translatedPost.slug

  return (
    <>
      {/* JSON-LD Structured Data */}
      <script
        type="application/ld+json"
        dangerouslySetInnerHTML={{ __html: JSON.stringify(jsonLd) }}
      />

      {/* Header overlay on hero - Logo and Language Switcher */}
      <div className="absolute top-0 left-0 right-0 z-50">
        <div className="max-w-full mx-auto px-8 py-4">
          <div className="flex items-center justify-between w-full">
            {/* Left side: White Logo */}
            <div className="flex items-center">
              <Link href="/blog">
                <LogoImage 
                  src="https://wxprzwoylqjzozhezttc.supabase.co/storage/v1/object/public/blog-images/logos/cuddlynest-logo.png"
                  alt="CuddlyNest Logo"
                  className="h-10 w-auto cursor-pointer filter brightness-0 invert"
                />
              </Link>
            </div>
            
            {/* Right side: Language switcher */}
            <div className="flex items-center ml-auto pr-4">
              <LanguageSwitcher
                currentLanguage={language}
                postSlug={baseSlug}
                availableTranslations={translations || []}
              />
            </div>
          </div>
        </div>
      </div>

      {/* Draft Preview Banner */}
      {isPreview && translatedPost.status === 'draft' && (
        <div className="bg-orange-100 border-b border-orange-200">
          <div className="max-w-full mx-auto px-8 py-3">
            <div className="flex items-center justify-center gap-2">
              <div className="w-2 h-2 bg-orange-500 rounded-full animate-pulse"></div>
              <span className="text-orange-800 font-medium text-sm">
                DRAFT PREVIEW - This post is not published yet
              </span>
              <div className="w-2 h-2 bg-orange-500 rounded-full animate-pulse"></div>
            </div>
          </div>
        </div>
      )}

      {/* Dynamic Sections */}
      {hasSections ? (
        <DynamicSectionRenderer 
          sections={translatedPost.sections || []} 
          post={translatedPost}
        />
      ) : (
        <div className="min-h-screen bg-white" style={{ backgroundColor: 'white' }}>
          <div className="max-w-4xl mx-auto px-4 sm:px-6 lg:px-8 py-12">
            <div className="bg-white rounded-lg shadow-sm border p-8" style={{ backgroundColor: 'white' }}>
              <div className="text-center py-12 text-gray-500">
                <h1 className="text-3xl font-bold text-gray-900 mb-4">{translatedPost.title}</h1>
                <p className="text-lg mb-6">{translatedPost.excerpt}</p>
                <p>This post doesn't have any content sections yet.</p>
                <p className="text-sm mt-2">Check back later for updates!</p>
                
                <div className="mt-8 p-4 bg-red-50 border border-red-200 rounded text-left text-sm">
                  <p className="font-bold text-red-800">Debug Info:</p>
                  <p>Post ID: {translatedPost.id}</p>
                  <p>Sections: {translatedPost.sections?.length || 0}</p>
                  <p>Country: {country || 'none'}</p>
                  <p>Language: {language}</p>
                  <p>Full Slug: {fullSlug}</p>
                  <p>Original WP ID: {(translatedPost as any).original_wp_id || 'none'}</p>
                  <p>Featured Image URL: {(translatedPost as any).featured_image_url || 'none'}</p>
                  {translatedPost.sections && translatedPost.sections.length > 0 && (
                    <div className="mt-2">
                      <p className="font-bold">Sections:</p>
                      <pre className="text-xs bg-gray-100 p-2 rounded">
                        {JSON.stringify(translatedPost.sections.map(s => ({
                          id: s.id,
                          template_id: s.template_id,
                          is_active: s.is_active,
                          sort_order: s.sort_order
                        })), null, 2)}
                      </pre>
                    </div>
                  )}
                </div>
              </div>
            </div>
          </div>
        </div>
      )}

      {/* Footer */}
      <Footer />
    </>
  )
  } catch (error) {
    console.error('Error in BlogPostPage:', error)
    return (
      <div className="min-h-screen flex items-center justify-center bg-gray-50">
        <div className="max-w-md w-full bg-white rounded-lg shadow-md p-6 text-center">
          <h1 className="text-2xl font-bold text-gray-900 mb-4">Page Error</h1>
          <p className="text-gray-600 mb-6">
            There was an error loading this page. Please try again later.
          </p>
          <p className="text-sm text-gray-500">
            Error: {error instanceof Error ? error.message : 'Unknown error'}
          </p>
        </div>
      </div>
    )
  }
}

// Generate metadata for SEO with hreflang support
export async function generateMetadata({ params }: BlogPostPageProps) {
  const resolvedParams = await params
  
  // Parse the slug array to determine country, language, and post slug
  const slugArray = resolvedParams.slug
  let country: string | null = null
  let language: string = 'en'
  let postSlug: string | null = null
  let fullSlug: string | null = null

  if (slugArray.length === 2) {
    country = slugArray[0]
    postSlug = slugArray[1]
    fullSlug = `${country}/${postSlug}`
  } else if (slugArray.length === 3) {
    country = slugArray[0]
    language = slugArray[1]
    postSlug = slugArray[2]
    fullSlug = `${country}/${postSlug}`
  } else if (slugArray.length === 1) {
    postSlug = slugArray[0]
    fullSlug = postSlug
  } else {
    return {
      title: 'Page Not Found',
      description: 'The requested page could not be found.'
    }
  }
  
  // First try to get modern post with full slug, then fallback to postSlug
  let post = await getModernPostBySlug(fullSlug)
  
  // If not found with full slug, try with just the post slug (original format)
  if (!post && postSlug) {
    post = await getModernPostBySlug(postSlug)
  }
  
  let legacyPost = null
  
  // If no modern post found, try legacy blog_posts table
  if (!post && postSlug) {
    legacyPost = await getLegacyBlogPostBySlug(postSlug)
  }
  
  if (!post && !legacyPost) {
    return {
      title: 'Post Not Found',
      description: 'The requested post could not be found.'
    }
  }

  // Handle legacy post metadata
  if (legacyPost && !post) {
    return {
      title: legacyPost.seo_title || legacyPost.title,
      description: legacyPost.meta_description || legacyPost.excerpt,
      keywords: `travel, ${legacyPost.title}, travel guide`,
      alternates: {
        canonical: `/blog/${fullSlug}`,
      },
      openGraph: {
        title: legacyPost.seo_title || legacyPost.title,
        description: legacyPost.meta_description || legacyPost.excerpt,
        type: 'article',
        locale: language,
        publishedTime: legacyPost.published_at,
        modifiedTime: legacyPost.modified_at || legacyPost.updated_at,
        authors: ['CuddlyNest Travel Team'],
        images: legacyPost.featured_image_url ? [{
          url: legacyPost.featured_image_url,
          alt: legacyPost.title
        }] : []
      },
      twitter: {
        card: 'summary_large_image',
        site: '@cuddlynest',
        title: legacyPost.seo_title || legacyPost.title,
        description: legacyPost.meta_description || legacyPost.excerpt,
        images: legacyPost.featured_image_url ? [{
          url: legacyPost.featured_image_url,
          alt: legacyPost.title
        }] : []
      },
    }
  }

  // Get all translations for hreflang
  const { data: allTranslations } = await supabase
    .from('post_translations')
    .select('language_code, translated_slug')
    .eq('original_post_id', post.id)
    .eq('translation_status', 'completed')

  // Build comprehensive hreflang object with new URL structure
  const currentUrl = `/blog/${slugArray.join('/')}`
  const languages: Record<string, string> = {
    'en': currentUrl, // Current page URL
    'x-default': currentUrl // Default fallback
  }
  
  // Add all completed translations using new URL structure
  if (allTranslations && allTranslations.length > 0) {
    allTranslations.forEach(translation => {
      if (country) {
        languages[translation.language_code] = `/blog/${country}/${translation.language_code}/${postSlug}`
      } else {
        // For posts without country, append language code
        languages[translation.language_code] = `/blog/${post.slug}/${translation.language_code}`
      }
    })
  }

  // Handle translated metadata if this is a non-English page
  let finalTitle = post.seo_title || post.title
  let finalDescription = post.seo_description || post.excerpt
  
  if (language !== 'en' && allTranslations) {
    const translation = allTranslations.find(t => t.language_code === language)
    if (translation) {
      const { data: translationData } = await supabase
        .from('post_translations')
        .select('translated_title, translated_excerpt, seo_data')
        .eq('original_post_id', post.id)
        .eq('language_code', language)
        .single()

      if (translationData) {
        finalTitle = translationData.seo_data?.seo_title || translationData.translated_title || finalTitle
        finalDescription = translationData.seo_data?.seo_description || translationData.translated_excerpt || finalDescription
      }
    }
  }

  return {
    title: finalTitle,
    description: finalDescription,
    keywords: post.meta_keywords || `travel, ${post.title}, travel guide`,
    alternates: {
      canonical: `/blog/${slugArray.join('/')}`,
      languages: languages
    },
    openGraph: {
      title: post.og_title || finalTitle,
      description: post.og_description || finalDescription,
      type: 'article',
      locale: language,
      alternateLocale: allTranslations?.map(t => t.language_code) || [],
      publishedTime: post.published_at,
      modifiedTime: post.updated_at || post.published_at,
      authors: [post.author?.display_name || 'CuddlyNest Travel Team'],
      images: post.og_image?.file_url ? [{
        url: post.og_image.file_url,
        alt: post.og_image_alt || post.title
      }] : []
    },
    twitter: {
      card: 'summary_large_image',
      site: '@cuddlynest',
      title: post.twitter_title || post.og_title || finalTitle,
      description: post.twitter_description || post.og_description || finalDescription,
      images: post.twitter_image || post.og_image?.file_url ? [{
        url: post.twitter_image || post.og_image?.file_url,
        alt: post.twitter_image_alt || post.og_image_alt || post.title
      }] : []
    },
    robots: {
      index: post.robots_index !== false,
      follow: post.robots_follow !== false,
      nosnippet: post.robots_nosnippet === true,
      googleBot: {
        index: post.robots_index !== false,
        follow: post.robots_follow !== false,
        'max-video-preview': -1,
        'max-image-preview': 'large',
        'max-snippet': -1,
      },
    },
  }
}